[{"title":"5. 你好，窗口","path":"/2025/08/24/你好，窗口/","content":"打通 Vulkan 向 GLFW 窗口绘制的通路在本节中我们将通过 Vulkan Swapchain 向窗口绘制一个深蓝色背景 创建一个 Instance使用 Vulkan 的第一件事通常就是创建一个 instance。一个 instance 连接你的应用与 Vulkan 库（包括下层的 GPU 驱动）的桥梁。 首先我们在代码框架中添加一个 initVulkan 函数用于放置 Vulkan 初始化相关的代码； class LearnVulkanApplication public: void run() initWindow(); initVulkan(); // 我们新添加的函数 mainLoop(); // ... 省略其余代码 // ... 省略其余代码 之后我们添加一个 VkInstance 成员变量用于存放一个 Vulkan Instance 对象。 class LearnVulkanApplication private: // ... VkInstance instance; 我们创建一个 createInstance 函数用于创建 Vulkan Instance 实例 class LearnVulkanApplication public: // ... void createInstance() VkApplicationInfo appInfo; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = Vulkan Triangle; appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.pEngineName = No Engine; appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); appInfo.apiVersion = VK_API_VERSION_1_0; VkInstanceCreateInfo createInfo; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pApplicationInfo = appInfo; uint32_t glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; createInfo.ppEnabledExtensionNames = glfwExtensions; if (enableValidationLayers) createInfo.enabledLayerCount = static_castuint32_t(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); else createInfo.enabledLayerCount = 0; if (vkCreateInstance(createInfo, nullptr, instance) != VK_SUCCESS) throw std::runtime_error(failed to create instance!); 将 createInstance 函数放置到 initVulkan 函数中 class LearnVulkanApplication public: // ... void initVulkan() createInstance(); // ... // ... 记得在 cleanup 函数中添加 instance 的销毁代码 class LearnVulkanApplication public: // ... void cleanup() vkDestroyInstance(instance, nullptr); // 新增 glfwDestroyWindow(window); glfwTerminate(); // ... 启用 Vulkan 校验层什么是 Vulkan 校验层Vulkan API 被设计城一层很薄的 API，这样做的一个副作用就是在 API 默认情况下只有很有限的错误检查支持，比如很多类似枚举值传递错误之类的简单的错误也不会给出准确的报错位置，而是会直接导致崩溃或者其他未定义行为(Undefined Behavior [UB])。然而，这并不意味着程序员没有调试 Vulkan API 错误的手段。Vulkan 引入了一种额外的系统被称为校验层。校验层是 VulkanSDK 中一个可选的组件，可以通过通过在 Vulkan 函数调用操作之前或之后插入校验代码来实现错误检查。校验层可以提供诸如：参数范围检查，GPU/CPU内存泄漏检查，线程安全性检查，Vulkan调用日志追踪与分析等功能的支持。 使用校验层Vulkan 的校验层有很多不同的实现，我们首先需要知道我们要使用的校验层是谁，所以我们需要通过名称来指定校验层。VulkanSDK 提供了一个标准校验层名为 “VK_LAYER_KHRONOS_validation”, 这就是我们在本教程中将要使用的校验层。由于校验层在进行 Vulkan API 调用时需要进行额外的检查，所以会拖累性能，通常我们只在开发调试的时候进行使用，在最终发布版本中关闭校验层，在标准 C++ 中，通常使用 NDEBUG 宏来表示是否在调试模式下编译。 创建一个 Surface","categories":["LearnVulkan"]},{"title":"4. 创建窗口","path":"/2025/07/02/创建窗口/","content":"程序骨架搭建首先创建承载程序主要应用逻辑的主类: class LearnVulkanApplication public: void run() initWindow(); mainLoop(); cleanup(); private: // 初始化窗口 void initWindow() // 主循环 void mainloop() // 清理资源 void clearup() 创建 main 函数调起应用程序主循环: int main() LearnVulkanApplication app; try app.run(); catch (const std::exception e) std::cerr e.what() std::endl; return EXIT_FAILURE; return EXIT_SUCCESS; 在创建的 ‘main.cpp’ 文件头部包含必要的头文件: #include iostream#include stdexcept#include cstdlib // for EXIT_SUCCESS/EXIT_FAILURE 引入 GLFW 头文件然后我们引入 ‘GLFW/glfw3.h’ 头文件，这里我们可以在包含 glfw3.h 之前定义 GLFW_INCLUDE_VULKAN 来通过 GLFW 引入 vulkan 头文件，避免我们手动包含 vulkan.h 头文件[1] #define GLFW_INCLUDE_VULKAN#include GLFW/glfw3.h LearnVulkanApplication::initWindow 函数施工我们在 initWindow 中初始化 glfw 环境，使用 glfw 创建一个窗口; 首先在代码顶部声明两个全局变量用于记录窗口宽高 #define GLFW_INCLUDE_VULKAN#include GLFW/glfw3.h#include iostream#include stdexcept#include cstdlib // for EXIT_SUCCESS/EXIT_FAILUREconst uint32_t WIDTH = 800;const uint32_t HEIGHT = 600;// 其余代码... 在 LearnVulkanApplication 类中声明一个 private 成员变量 class LearnVulkanApplication // 其余代码...private: GLFWwindow* window nullptr ; // 其余代码... 填充 initWindow 函数的逻辑 void initWindow() glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 不创建 OpenGL 上下文 window = glfwCreateWindow(WIDTH, HEIGHT, LearnVulkan, nullptr, nullptr); LearnVulkanApplication::mainLoop 函数施工我们在 mainLoop 函数中调用每帧的事件处理 // 主循环void mainLoop() while (!glfwWindowShouldClose(window)) glfwPollEvents(); LearnVulkanApplication::cleanup 函数施工我们在 cleanup 函数中清理我们创建的所有资源 // 清理资源void cleanup() glfwDestroyWindow(window); glfwTerminate(); 运行项目我们运行该工程，会看到一个空白的窗口。干的好，这就是我们之后绘制的地方。 完整代码git tag：’创建窗口’可以通过 git 克隆教程配套代码: git clone https://github.com/sike2017/LearnVulkan.git 然后使用 git checkout 签出当前文章的 tag 获取完整代码: git checkout 创建窗口 引用[1] glfw3.h 中 GLFW_INCLUDE_VULKAN 宏对于的引入 vulkan.h 的代码实现如下","categories":["LearnVulkan"]},{"title":"3. 我们的第一个工程","path":"/2025/06/19/我们的第一个工程/","content":"在这一章节我们将会搭建起一个包含 窗口库GLFW/数学库GLM/图形库Vulkan 的基本的开发环境 在我们实际使用 vulkan 画出一些东西之前，我们首先要有一个用于显示画面结果的窗口。不过，在不同的操作系统上窗口的管理方式不尽相同，好在有一些库使用抽象接口提供了统一了不同操作系统的窗口管理方式（例如 Qt6 GLFW SDL 等），让我们可以简单地完成跨平台的窗口创建工作，我们这里使用一个流行的库 GLFW 来实现。 本教程的所有项目编译配置均使用 64 位版本GLFW 编译和安装考虑到有很多不同操作系统的用户，预编译的包在某些系统上不都总是存在，我们在这里手动从源代码编译 GLFW 库 从 https://www.glfw.org/ 下载最新的 glfw 源代码； 解压源代码到你想要的文件夹； 使用 cmake-gui 软件打开该 GLFW 项目； 选择合适的构建目录； 点击 ‘Configure’ 按钮，如果询问是否创建目录，点击 ‘Yes’; 选择合适的 IDE，笔者这里选择 Visual Studio 17 2022, 默认为 64 位； 点击 ‘Finish’; 在运行结束后，搜索 ‘CMAKE_INSTALL_PREFIX’ 选项，修改为你想要安装的目标目录； 点击 ‘Generate’ 按钮； 使用您的 IDE 打开对应生成的项目，编译安装即可；对于 Windows 下 Visual Studio 2022 用户，切换到 Release 模式构建 INSTALL 项目即可； 构建成功后在刚才 cmake 指定的 CMAKE_INSTALL_PREFIX 路径目录下，即可看到编译和安装好的库；（笔者这里是 L:/code/LearnVulkan/third_party/glfw_installed 目录） 至此便已成功编译和安装完成了 GLFW 库 Vulkan SDK 的安装请前往 LUNARG 官网 https://vulkan.lunarg.com 按照您的环境自行安装 安装完毕后可以通过运行 ‘Vulkan Cube.exe’ 检验是否安装成功； GLM 的安装由于 GLM 是一个 Header Only 的库，仅需包含它的头文件即可使用，所以这里可以直接前往 https://github.com/g-truc/glm/releases/tag/1.0.1 下载最新版本的 glm 代码包，解压的您需要的位置； 创建我们的第一个工程在这里我们使用 cmake 创建我们的第一个 Vulkan 工程； 首先在合适位置创建一个用于存放工程的文件夹（笔者这里为 ‘D:/code/LearVulkan’）； 使用你的 IDE（笔者这里使用 VSCode 作为 IDE）打开这个工程文件夹，在文件夹中按照如下结构创建 main.cpp 和 CMakeLists.txt 文件在 CMakeLists.txt 文件中，填写如下内容：cmake_minimum_required(VERSION 3.10)project(LearnVulkan)set(CMAKE_CXX_STANDARD 20)set(CMAKE_CXX_STANDARD_REQUIRED ON)find_package(Vulkan REQUIRED)set(GLFW_DIR CACHE PATH Path to GLFW installation)set(GLM_DIR CACHE PATH Path to GLM installation)set(GLFW_INCLUDE_DIR $GLFW_DIR/include)set(GLFW_LIBRARY_DIR $GLFW_DIR/lib)set(GLM_INCLUDE_DIR $GLM_DIR/include)add_executable(LearnVulkan src/main.cpp)target_include_directories( LearnVulkan PRIVATE $Vulkan_INCLUDE_DIRS $GLFW_INCLUDE_DIR $GLM_INCLUDE_DIR)target_link_directories( LearnVulkan PRIVATE $GLFW_LIBRARY_DIR)target_link_libraries(LearnVulkan $Vulkan_LIBRARIES glfw3) 使用 cmake-gui 打开刚才创建的工程文件，指定合适的构建目录， 点击 ‘Configure’, 按需选择合适的IDE版本等信息； 配置 GLFW_DIR 和 GLM_DIR 到之前安装的目录下； 再次点击 ‘Configure’; 无误后点击 ‘Generate’; 点击 ‘Open Project’ 打开生成的项目；","categories":["LearnVulkan"]},{"title":"2. VulkanAPI概述","path":"/2025/06/18/VulkanAPI概述/","content":"Vulkan 起源和历史与之前的图形 API 一样，Vulkan 被设计为基于 GPU的跨平台抽象接口。大多数此类 API 受限于其设计年代，当时的图形硬件大多局限于可配置的固定功能。程序员必须以标准格式为图形硬件提供数据顶点数据，并且在光照/着色等选项上完全受 GPU 制造商的控制。 随着显卡硬件的发展，它们提供的功能越来越丰富，灵活。所有这些新功能都必须以某种心事与现有 API 集成。这超出了很多之前图形API的设计支撑能力，导致抽象不够理想，很多勉强缝合的功能会导致程序设计意图不能很好地映射到现代图形硬件架构上。为了解决过时的图形API抽象架构与不断发展的图形硬件架构之间不能准确协调工作的问题，人类引入了 Vulkan 这类转为现代图形硬件架构而设计的接口。 它允许程序员使用更详细的API明确指定人类的意图，从而避免了很多之前需要显卡驱动进行的某些“猜测”的工作，从而降低了驱动程序开销。 Vulkan 摆脱原有API局限的思路 类似于 C++ 编译器的优化，程序员由于知道更多的业务信息所以可以做出许多在编译器看来根本无法实现的从“人类”的层面进行的优化。由于软件自身对自身的执行意图信息了解的最准确/全面，所以理论上只有软件自身才能做出最符合它自己的优化。Vulkan 更依赖程序自身的认知，让程序有更多的控制权，而不尝试在驱动后台进行优化，程序自身的优化可操作性很高。 多线程友好。抛弃旧有的和线程绑定的 Context 上下文，使用独立的 Queue 取而代之，搭配多种线程同步方法，降低多线程编码难度。 强调复用。大多数 Vulkan API 组件都可以高效地被复用。","categories":["LearnVulkan"]},{"title":"1. LearnVulkan简介","path":"/2025/06/16/LearnVulkan简介/","content":"欢迎来到 Vulkan 的世界欢迎来到Vulkan的世界。如你所见这是一个 Vulkan 的从零开始到PBR渲染的教程。截至笔者编写这篇文章为止(2025/06/16)，网络上尚且没有一个系统，开放，深入的学习 Vulkan 的教程（就像LearnOpenGL之于OpenGL，这也是笔者学习图形编程路上的良师益友），所以我开始了这个 LearnVulkan 工程，就如同 LearnOpenGL 教程作者所言，这个工程也只是我的一次小小尝试，希望能够建立起一个完善的Vulkan教学平台。 为什么要阅读这些教程呢？ 对于稍深入的实时渲染理论（比如 PBR/IBL/ShadowMap 等），主流教程依然以 OpenGL/WebGL/DirectX 作为主要实现接口，对于初学者来说如果要在 Vulkan 上进行实践，将不得不同时学习其他图形接口，以便将其他平台的知识迁移到 Vulkan 中来，对于初学者来说，渲染图形 API 本身已经足够复杂，掌握一个尚且费力，同时参考多个进行学习客观上确实难度较大； 现在市面上不乏很多优秀的 Vulkan 教程，但是大多只是介绍了 Vulkan API 本身的使用，而没有在Vulkan基础上引入渲染理论的实践，这样确实能够很好地完成初学者入门的工作，但是稍微深入就需要落入前一点所指学习多个API的窘境中，这对于初学者来说极不友好； Vulkan 作为现代图形API，为了适应现代计算机硬件的发展，与上一世代的以 OpenGL 为代表的图形API 的设计哲学有着巨大的差异，所以对于同时学习 OpenGL 与 Vulkan 的同学来说，需要在同时兼容两种不同思维的转变，这对于初学者来说极不友好； 一言以蔽之：此教程是为了降低一个对图形API初学者入门的难度，帮助初学者直接从Vulkan一门API入门现代图形编程。你将学会什么呢？我这些教程的核心是Vulkan。学习和使用 Vulkan 需要用户对图形编程以及显卡硬件的幕后运作有非常好的理解。所以，我们会首先讨论核心的图形学概念，Vulkan 调用 GPU 做了什么才将像素绘制到屏幕上，以及如何利用一些黑科技做出一些很酷的效果。 除了核心概念之外，我们还会讨论许多实用的技巧，它们都可以用在你的程序中，比如在场景中移动，做出漂亮的光照，加载建模软件中导出的自定义模型，添加一些很酷的后处理技巧等。 阅读该教程的前置条件 内地中数学基础； 基础的面向对象编程概念； 基本的 C++ 编码能力；","categories":["LearnVulkan"]}]